<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sWorkerEnemy</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>oEnemyParent</parentName>
  <maskName>sShipMaskSmall</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Init
event_inherited();

scrUnitInit(ENEMYINDEX, 3, 1.75, 0.25, 0.15, 3,
            0, 0, 0, 0, 0, sBullet, true, "worker");

// Mining Variables
workerMiningInt = 0;
workerMiningTarget = 120;
mineX = 0;
mineY = 0;
idleDelayInt = 0;
idleDelayTarget = 180;
loadCheck = false;

// Drawing Variables
workerMiningBarAlpha = 0;
workerMiningBarAlphaTar = 0;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Move

// Child finite machine
if (loadInt &lt; loadTime) {
    loadInt++;
} else { 
    if (loadCheck == false) {
        // Goto nearest mine -&gt; here you make decisions based on clusters
        state = "findingMine"; 
        var inst = instance_nearest(x, y, oMiningPoint);
        mineX = inst.x;
        mineY = inst.y;
        loadCheck = true;
    }
}

if (instance_exists(oStationEnemy)) { 

    // If time is not frozen
    if (global.timeflow == 1) {
        switch(state) {
            case "idle":
                scrUnitIdle();
                if (idleDelayInt &lt; idleDelayTarget) {
                    idleDelayInt++;
                } else { 
                    // Goto nearest mine -&gt; here you make decisions based on clusters
                    state = "findingMine"; 
                    var inst = instance_nearest(x, y, oMiningPoint);
                    mineX = inst.x;
                    mineY = inst.y;
                }
            break;
            case "move":
                scrUnitMove();
            break;
            case "findingMine":
                scrUnitMove();
                //if (workerMiningInt &gt;= workerMiningTarget) { state = "return"; exit; }
                if (instance_exists(oMiningPoint)) {
                    var dis = point_distance(x, y, mineX, mineY);
                    if (dis &gt; sprite_width/2) {
                        atTarget = false;
                        moveTargetX = mineX;
                        moveTargetY = mineY;
                    } else {
                        state = "idle";
                        hsp = scrApproach(hsp,0,fric);
                        vsp = scrApproach(vsp,0,fric);
                        atTarget = true;
                    }
                } else { state = "idle"; }
            break;
            case "return": 
                scrUnitMove();
                if (instance_exists(oStationEnemy)) {
                    atTarget = false;
                    moveTargetX = oStationEnemy.x;
                    moveTargetY = oStationEnemy.y;
                }
            break;
        }   
            
        // Returning to the station
        if (instance_exists(oStationEnemy)) {
            if (place_meeting(x, y, oStationEnemy) &amp;&amp; state == "return") {
                state = "findingMine";
                workerMiningInt = 0;
                global.enemyCurrency += 10;  
            }
        }
        // Going to the mining point
        if (instance_exists(oMiningPoint)) {
            if (place_meeting(x, y, oMiningPoint) &amp;&amp; state == "idle") {
                var inst = instance_nearest(x, y, oMiningPoint);
                mineX = inst.x;
                mineY = inst.y;
                workerMiningBarAlphaTar = 1;
                if (workerMiningInt &lt; workerMiningTarget) {
                    workerMiningInt++;
                } else {
                    state = "return";
                    atTarget = false;
                    moveTargetX = oStationEnemy.x;
                    moveTargetY = oStationEnemy.y;
                } 
            } else {
                workerMiningBarAlphaTar = 0;
            }
        }
        
        x += hsp; 
        y += vsp; 
    }

}

// Level-based AI
if (global.difficulty &gt;= 3 &amp;&amp; hp &lt; maxHp) {
    scrEnemyAvoidPlayerShip();
}

// Toggle Select
if (mouse_check_button(mb_left)) {
    scrToggleSelect(oMouse.px, oMouse.py, mouse_x, mouse_y);
}

// Clamp within room bounds
x = clamp(x, 0, room_width); 
y = clamp(y, 0, room_height); 

// Damage
scrUnitTakeDamage();

// Sprite work
scrReturnSquish(1, 0.2);

// Particles 
if (abs(hsp) &gt;= (maxSpd/4) || abs(vsp) &gt;= (maxSpd/4)) {
    part_particles_create(global.pSysBelow, x, y, global.partShipEnemyTrail, choose(0,1));
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw
event_inherited();

workerMiningBarAlpha = lerp(workerMiningBarAlpha, workerMiningBarAlphaTar, 0.1);

draw_set_alpha(workerMiningBarAlpha);
draw_set_colour(c_white);
draw_rectangle(x - 16, y + 16 - 1, x + 16, y + 16 + 2, true);
var pc = (workerMiningInt / workerMiningTarget) * 100;
draw_healthbar(x - 16, y + 16, x + 16, y + 16 + 2, pc, c_white, c_white, c_white, 0, false, false);
draw_set_alpha(1);



</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
