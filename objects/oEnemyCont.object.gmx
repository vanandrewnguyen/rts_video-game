<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Init
global.difficulty = 3;
timePassed = 0;
timeWave = -60*8; //0;
count = 0;

/* Establish difficulty settings using a 2D array. 
dif[i, 0] = cluster size
dif[i, 1] = wait time
*/

// Cluster Size
dif[0,0] = 2;
dif[1,0] = 4;
dif[2,0] = 7;
dif[3,0] = 8;
dif[4,0] = 10;

// Variation in cluster size (lower bound)
dif[0,1] = -1;
dif[1,1] = -1;
dif[2,1] = -2;
dif[3,1] = -2;
dif[4,1] = -3;
//                           (upper bound)
dif[0,2] = 1;
dif[1,2] = 1;
dif[2,2] = 2;
dif[3,2] = 2;
dif[4,2] = 3;

// Wait times to spawn in new units (seconds)
bufferSpawnTime = 30; // to be added on top of first spawn (TODO)
dif[0,3] = 8;
dif[1,3] = 10;
dif[2,3] = 14;
dif[3,3] = 18;
dif[4,3] = 24;

// Attack waves (wait until this time to send most units)
dif[0,4] = 60;
dif[1,4] = 90;
dif[2,4] = 100;
dif[3,4] = 120;
dif[4,4] = 150;


// Chances to spawn in ships
scrResetSpawnChances();

// Commands are listed in order of first check to last

command[0, 0] = "guardPoint";
command[1, 0] = "guardBase";
command[2, 0] = "guardHighestMinefield";
command[3, 0] = "targetNearestPlayer";
command[4, 0] = "guardNearestMinefield";
command[5, 0] = "targetPlayerBase";
command[0, 1] = 0.1;
command[1, 1] = 0.1;
command[2, 1] = 0.1;
command[3, 1] = 0.1;
command[4, 1] = 0.1;
command[5, 1] = 0.1;

// Conditionals
if (room == rmArenaBasicExt) {
    global.difficulty = 2;
    global.currency = 60;
} else if (room == rmArenaBasic) {
    global.difficulty = 1;
    global.currency = 40;
} else if (room == rmArenaMinimal) {
    global.difficulty = 3;
    global.currency = 400;
} else if (room == rmArenaDoublePass) {
    global.difficulty = 3;
    global.currency = 150;
} else if (room == rmArenaDuo) {
    global.difficulty = 4;
    global.currency = 100;
} else if (room == rmArenaQuadFlank) {
    global.difficulty = 4;
    global.currency = 50;
} else if (room == rmArenaDuoFlank) {
    global.difficulty = 4;
    global.currency = 50;
} 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Execute Director AI
if (global.timeflow == 1) {
    timePassed++;
    timeWave++;
}

var d = global.difficulty;

if (!instance_exists(oStationEnemy) || !instance_exists(oStation)) { exit; }


// Execute waves
if (timeWave &gt; (dif[d, 3]*60)) {
    /*
    First we check our money, then player ships (number of workers / number of fighters), 
    then finally, we check our own number of fighters to give preference.
    We have a preset cluster (using our own sets of ships)
    and a random cluster which only spawns using chance. The random cluster
    is to add variation.
    */
    var xGap = -72 + random_range(-32, 32);
    var yGap = random_range(-64, 64);
    var xx = oStationEnemy.x + xGap;
    var yy = oStationEnemy.y + yGap;
    
    var finalClusterSize = dif[d, 0] + random_range(dif[d, 1], dif[d, 2]);
    var setClusterSize = round(finalClusterSize * 0.75);
    var randomClusterSize = finalClusterSize - setClusterSize;
    
    // Money Check
    if (global.enemyCurrency &lt; 50 * global.difficulty) {
        if (oStationEnemy.hp &lt; 10) {
            dif[1, 5] += 0.05;
        }
        // 50% chance to create a worker / freighter ship to collect money
        dif[0, 5] += 0.1;
    }
    
    // Check Player Ships
    
    // Check Enemy Ships
    
    // Check Difficulty Settings
    switch(d) {
        case 0: 
        dif[0, 5] += 0.1; dif[1, 5] += 0.1; dif[2, 5] = 0; dif[3, 5] = 0; dif[4, 5] = 0;
        break;
        case 1: dif[2, 5] = 0; dif[3, 5] = 0;
        break;
        case 2: dif[2, 5] = 0; dif[3, 5] += 0.1;
        break;
        case 3: dif[2, 5] += 0.1;
        break;
        case 4: 
        dif[0, 5] += 0.1; dif[1, 5] += 0.2; dif[3, 5] += 0.2;
        dif[2,5] += 0.25; 
        break;
    }
    
    // Command for cluster
    var currentCommand = scrSetEnemyClusterObj();
    var clusterInst = instance_create(xx, yy, oEnemyCluster);
    clusterInst.command = currentCommand; 
    var spread = 96;
    switch(currentCommand) {
        case "guardPoint": // Guards the middle point between all player ships
        var xx = 0;
        var yy = 0;
        var num = instance_number(oUnitParent);
        if (num == 0) {
            if (instance_exists(oStation)) {
                clusterInst.targetX = oStation.x;
                clusterInst.targetY = oStation.y;
            }
        } else {
            for (var i=0;i&lt;num;++i) {
                var inst = instance_find(oUnitParent, i);
                xx += oUnitParent.x;
                yy += oUnitParent.y;
            }
            xx /= num;
            yy /= num;
            clusterInst.targetX = xx + random_range(-spread, spread);
            clusterInst.targetY = yy + random_range(-spread, spread);
        }
        break;
        case "guardBase": // Guards the Enemy Base
        clusterInst.targetX = oStationEnemy.x + random_range(-spread, spread);
        clusterInst.targetY = oStationEnemy.y + random_range(-spread, spread);
        break;
        case "guardHighestMinefield": // Selects the minefield with the highest mines and guards it
        var highestSum = 0;
        var highestMine = noone;
        for (var i=0;i&lt;instance_number(oMiningPoint);++i) {
            var inst = instance_find(oMiningPoint, i);
            if (inst.totalMines &gt; highestSum) {
                highestSum = inst.totalMines;
                highestMine = inst.id;
            }
        }
        if (highestMine != noone) {
            clusterInst.targetX = highestMine.x + random_range(-spread, spread);
            clusterInst.targetY = highestMine.y + random_range(-spread, spread);
        } else {
            clusterInst.targetX = oStationEnemy.x + random_range(-spread, spread);
            clusterInst.targetY = oStationEnemy.y + random_range(-spread, spread);
        }
        break;
        case "targetNearestPlayer": // Targets the nearest player ship
        if (instance_exists(oUnitParent)) {
            var inst = instance_nearest(xx, yy, oUnitParent);
            if (instance_exists(inst)) {
                clusterInst.targetX = inst.x;
                clusterInst.targetY = inst.y;
            }
        } else {
            clusterInst.targetX = oStationEnemy.x + random_range(-spread, spread);
            clusterInst.targetY = oStationEnemy.x + random_range(-spread, spread);
        }
        break;
        case "guardNearestMinefield": // Selects the nearest minefield and guards it
        if (instance_exists(oMiningPoint)) {
            var inst = instance_nearest(xx, yy, oMiningPoint);
            if (instance_exists(inst)) {
                clusterInst.targetX = inst.x + random_range(-spread, spread);
                clusterInst.targetY = inst.y + random_range(-spread, spread);
            }
        } else {
            clusterInst.targetX = oStationEnemy.x + random_range(-spread, spread);
            clusterInst.targetY = oStationEnemy.x + random_range(-spread, spread);
        }
        break;
        case "targetPlayerBase": // Targets the nearest player base
        if (instance_exists(oStation)) {
            var inst = instance_nearest(xx, yy, oStation);
            if (instance_exists(inst)) {
                clusterInst.targetX = inst.x;
                clusterInst.targetY = inst.y;
            }
        } else {
            clusterInst.targetX = oStationEnemy.x + random_range(-spread, spread);
            clusterInst.targetY = oStationEnemy.x + random_range(-spread, spread);
        }
        break;
    }
    
    // Create the preset ships
    switch(d) {
        case 0: // Base Difficulty
            var numWorkers = 2;
            if (!instance_exists(oMiningPoint) || instance_number(oWorkerEnemy) &lt; 10 &amp;&amp;
                global.currency &gt; 200) {
                numWorkers--;   
            }
            repeat(numWorkers) {
                if (instance_number(oWorkerEnemy) &lt; 12) {
                    scrSpawnEnemy(xx+random_range(-64,64), yy, oWorkerEnemy, clusterInst);
                    setClusterSize--;
                }
            }
            repeat(setClusterSize) {
                if (instance_number(oInfantryEnemy) &lt; 12) {
                    scrSpawnEnemy(xx+random_range(-64,64), yy, oInfantryEnemy, clusterInst);
                }
            }
        break;
        case 1: // Easy Difficulty
            if (currentCommand == "targetPlayerBase" || currentCommand == "targetNearestPlayer") {
                repeat(setClusterSize) {
                    var spawnInst = choose(oInfantryEnemy, oInfantryEnemy, oKamikazeEnemy);
                    scrSpawnEnemy(xx+random_range(-64,64), yy, spawnInst, clusterInst);
                }
            } else if (currentCommand == "guardHighestMinefield" || currentCommand == "guardNearestMinefield") {
                repeat(setClusterSize) {
                    var spawnInst = choose(oInfantryEnemy, oInfantryEnemy, oInfantryEnemy, oWorkerEnemy);
                    scrSpawnEnemy(xx+random_range(-64,64), yy, spawnInst, clusterInst);
                }
            } else {
                repeat(setClusterSize-1) {
                    if (instance_number(oWorkerEnemy) &lt; 10) {
                        scrSpawnEnemy(xx+random_range(-64,64), yy, oWorkerEnemy, clusterInst);
                    } else {
                        scrSpawnEnemy(xx+random_range(-64,64), yy, oKamikazeEnemy, clusterInst);
                        clusterInst.command = "targetPlayerBase";
                    }
                }
                scrSpawnEnemy(xx+random_range(-64,64), yy, oInfantryEnemy, clusterInst);
            }
        break;
        case 2: // Moderate Difficulty
            if (currentCommand == "targetPlayerBase" || currentCommand == "targetNearestPlayer") {
                repeat(setClusterSize) {
                    var spawnInst = choose(oTankEnemy, oInfantryEnemy, oInfantryEnemy, oKamikazeEnemy, oWorkerEnemy);
                    scrSpawnEnemy(xx+random_range(-64,64), yy, spawnInst, clusterInst);
                }
            } else if (currentCommand == "guardHighestMinefield" || currentCommand == "guardNearestMinefield") {
                repeat(setClusterSize) {
                    var spawnInst = choose(oSniperEnemy, oInfantryEnemy, oInfantryEnemy, oWorkerEnemy, oWorkerEnemy);
                    scrSpawnEnemy(xx+random_range(-64,64), yy, spawnInst, clusterInst);
                }
            } else {
                repeat(setClusterSize-1) {
                    if (instance_number(oWorkerEnemy) &lt; 10) {
                        scrSpawnEnemy(xx+random_range(-64,64), yy, oWorkerEnemy, clusterInst);
                    } else {
                        scrSpawnEnemy(xx+random_range(-64,64), yy, oKamikazeEnemy, clusterInst);
                        clusterInst.command = "targetPlayerBase";
                    }  
                }
                scrSpawnEnemy(xx+random_range(-64,64), yy, choose(oSniperEnemy, oInfantryEnemy), clusterInst);
            }
        break;
        case 3: // Hard Difficulty
            if (currentCommand == "targetPlayerBase" || currentCommand == "targetNearestPlayer") {
                repeat(setClusterSize/2) {
                    var spawnInst = choose(oBomberEnemy, oBomberEnemy, oKamikazeEnemy);
                    scrSpawnEnemy(xx+random_range(-64,64), yy, spawnInst, clusterInst);
                }
                repeat(setClusterSize/2) {
                    if (instance_number(oFreighterEnemy) &lt; 10) {
                        var spawnInst = choose(oFreighterEnemy);
                        scrSpawnEnemy(xx+random_range(-64,64), yy, spawnInst, clusterInst);
                    } else {
                        scrSpawnEnemy(xx+random_range(-64,64), yy, oKamikazeEnemy, clusterInst);
                        clusterInst.command = "targetPlayerBase";
                    }
                }
            } else if (currentCommand == "guardHighestMinefield" || currentCommand == "guardNearestMinefield") {
                repeat(setClusterSize) {
                    var spawnInst = choose(oSniperEnemy, oTankEnemy, oInfantryEnemy, oBomberEnemy, oFreighterEnemy);
                    scrSpawnEnemy(xx+random_range(-64,64), yy, spawnInst, clusterInst);
                }
            } else {
                repeat(setClusterSize*0.75) {
                    var spawnInst = choose(oSniperEnemy, oTankEnemy, oInfantryEnemy, oInfantryEnemy, oInfantryEnemy, oWorkerEnemy);
                    scrSpawnEnemy(xx+random_range(-64,64), yy, spawnInst, clusterInst);
                }
            } 
        break;
        case 4: // Hardest Difficulty
            if (currentCommand == "targetPlayerBase" || currentCommand == "targetNearestPlayer") {
                repeat(setClusterSize) {
                    var spawnInst = choose(oTankEnemy, oInfantryEnemy, oInfantryEnemy, oKamikazeEnemy, oWorkerEnemy);
                    scrSpawnEnemy(xx+random_range(-64,64), yy, spawnInst, clusterInst);
                }
            } else if (currentCommand == "guardHighestMinefield" || currentCommand == "guardNearestMinefield") {
                repeat(setClusterSize) {
                    var spawnInst = choose(oSniperEnemy, oInfantryEnemy, oInfantryEnemy, oWorkerEnemy, oWorkerEnemy, oGravityBoss);
                    scrSpawnEnemy(xx+random_range(-64,64), yy, spawnInst, clusterInst);
                }
            } else {
                repeat(setClusterSize) {
                    if (instance_number(oFreighterEnemy) &lt; 10) {
                        scrSpawnEnemy(xx+random_range(-64,64), yy, oFreighterEnemy, clusterInst);
                    } else {
                        var inst = choose(oBomberEnemy, oBomberEnemy, oWorkerEnemy);
                        scrSpawnEnemy(xx+random_range(-64,64), yy, inst, clusterInst);
                        clusterInst.command = "guardNearestMinefield";
                    }  
                }
                scrSpawnEnemy(xx+random_range(-64,64), yy, choose(oSniperEnemy, oInfantryEnemy), clusterInst);
            }
        break;
    }
    
    
    // Create the random ships
    repeat(randomClusterSize) {
        var spawnShip = noone;
        if (scrChance(dif[3, 5]) &amp;&amp; instance_number(oSniperEnemy) &lt; 4) {
            spawnShip = oSniperEnemy;
        } 
        if (scrChance(dif[2, 5]) &amp;&amp; instance_number(oTankEnemy) &lt; 4) {
            spawnShip = oTankEnemy;
        } 
        if (scrChance(dif[4, 5]) &amp;&amp; instance_number(oKamikazeEnemy) &lt; 8) {
            spawnShip = oKamikazeEnemy;
        }
        if (scrChance(dif[1, 5]) &amp;&amp; instance_number(oInfantryEnemy) &lt; 12) {
            spawnShip = choose(oInfantryEnemy, oBomberEnemy);
        }
        if (scrChance(dif[0, 5]) &amp;&amp; instance_number(oWorkerEnemy) &lt; 10) {
            if (d &lt;= 3) {
                spawnShip = oWorkerEnemy;
            } else {
                spawnShip = oFreighterEnemy;
            }
        }
        
        if (spawnShip != noone) {
            // Create Ship and assign it to a cluster object
            scrSpawnEnemy(xx+random_range(-64,64), yy, spawnShip, clusterInst);
        }
    }
    
    // Reset
    timeWave = 0;
    if (global.enemyCurrency &lt; 100) {
        timeWave -= (100-global.enemyCurrency)*8;
    }
    scrResetSpawnChances();
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Debug Draw
/*
var xx = mouse_x + 32;
var yy = mouse_y - 32;

draw_set_font(fntSma);
draw_set_colour(c_white);
draw_text(xx, yy, "time wave: "+string(timeWave));
draw_text(xx, yy + 16, "time target: "+string(dif[global.difficulty, 3]*60));
draw_text(xx, yy + 16*2, string(dif[0,5]));
draw_text(xx, yy + 16*3, string(dif[1,5]));
draw_text(xx, yy + 16*4, string(dif[2,5]));
draw_text(xx, yy + 16*5, string(dif[3,5]));
draw_text(xx, yy + 16*6, string(dif[4,5]));


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
